/**
 * @packageDocumentation
 *
 * A Blockstore implementation that stores blocks in the local filesystem.
 *
 * @example
 *
 * ```js
 * import { FsBlockstore } from 'blockstore-fs'
 *
 * const store = new FsBlockstore('path/to/store')
 * ```
 */
import { type ShardingStrategy } from './sharding.js';
import type { Blockstore, Pair } from 'interface-blockstore';
import type { AwaitIterable } from 'interface-store';
import type { CID } from 'multiformats/cid';
export interface FsBlockstoreInit {
    /**
     * If true and the passed blockstore location does not exist, create
     * it on startup. default: true
     */
    createIfMissing?: boolean;
    /**
     * If true and the passed blockstore location exists on startup, throw
     * an error. default: false
     */
    errorIfExists?: boolean;
    /**
     * The file extension to use when storing blocks. default: '.data'
     */
    extension?: string;
    /**
     * How many blocks to put in parallel when `.putMany` is called.
     * default: 50
     */
    putManyConcurrency?: number;
    /**
     * How many blocks to read in parallel when `.getMany` is called.
     * default: 50
     */
    getManyConcurrency?: number;
    /**
     * How many blocks to delete in parallel when `.deleteMany` is called.
     * default: 50
     */
    deleteManyConcurrency?: number;
    /**
     * Control how CIDs map to paths and back
     */
    shardingStrategy?: ShardingStrategy;
}
/**
 * A blockstore backed by the file system
 */
export declare class FsBlockstore implements Blockstore {
    path: string;
    private readonly createIfMissing;
    private readonly errorIfExists;
    private readonly putManyConcurrency;
    private readonly getManyConcurrency;
    private readonly deleteManyConcurrency;
    private readonly shardingStrategy;
    constructor(location: string, init?: FsBlockstoreInit);
    open(): Promise<void>;
    close(): Promise<void>;
    put(key: CID, val: Uint8Array): Promise<CID>;
    putMany(source: AwaitIterable<Pair>): AsyncIterable<CID>;
    get(key: CID): Promise<Uint8Array>;
    getMany(source: AwaitIterable<CID>): AsyncIterable<Pair>;
    delete(key: CID): Promise<void>;
    deleteMany(source: AwaitIterable<CID>): AsyncIterable<CID>;
    /**
     * Check for the existence of the given key
     */
    has(key: CID): Promise<boolean>;
    getAll(): AsyncIterable<Pair>;
}
//# sourceMappingURL=index.d.ts.map